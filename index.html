<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TRAINING ORGANIZER</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Barlow+Condensed:wght@300;400;600;700&family=Barlow:wght@300;400&display=swap');

  :root {
    --red: #e31c1c;
    --green: #00d46a;
    --yellow: #f5c400;
    --bg: #0d0d0d;
    --panel: #151515;
    --border: #2a2a2a;
    --text: #f0ece4;
    --muted: #666;
    --accent: #c8a45a;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Barlow Condensed', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* NOISE TEXTURE OVERLAY */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 9999;
    opacity: 0.4;
  }

  header {
    text-align: center;
    padding: 24px 20px 12px;
    border-bottom: 1px solid var(--border);
    position: relative;
  }

  header h1 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(2rem, 6vw, 4rem);
    letter-spacing: 0.15em;
    color: var(--accent);
    text-shadow: 0 0 40px rgba(200,164,90,0.3);
  }

  header p {
    font-size: 0.8rem;
    color: var(--muted);
    letter-spacing: 0.3em;
    text-transform: uppercase;
    margin-top: 4px;
  }

  .app-container {
    display: grid;
    grid-template-columns: 1fr 340px;
    gap: 0;
    max-width: 1400px;
    margin: 0 auto;
    min-height: calc(100vh - 90px);
  }

  /* ===== TIMER SECTION ===== */
  .timer-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 30px 40px;
    position: relative;
    border-right: 1px solid var(--border);
  }

  .phase-label {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.4rem;
    letter-spacing: 0.4em;
    color: var(--muted);
    transition: color 0.3s;
    margin-bottom: 10px;
  }

  .round-info {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.1rem;
    letter-spacing: 0.3em;
    color: var(--accent);
    margin-bottom: 20px;
  }

  .timer-ring {
    position: relative;
    width: min(380px, 80vw);
    height: min(380px, 80vw);
    margin: 10px auto;
  }

  .timer-ring svg {
    width: 100%;
    height: 100%;
    transform: rotate(-90deg);
  }

  .timer-ring .track {
    fill: none;
    stroke: #1e1e1e;
    stroke-width: 12;
  }

  .timer-ring .progress {
    fill: none;
    stroke-width: 12;
    stroke-linecap: round;
    transition: stroke-dashoffset 1s linear, stroke 0.3s ease;
  }

  .timer-display {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .time-digits {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(4rem, 12vw, 7rem);
    letter-spacing: 0.05em;
    line-height: 1;
    transition: color 0.3s;
    text-shadow: 0 0 30px currentColor;
  }

  .phase-sub {
    font-size: 0.75rem;
    letter-spacing: 0.35em;
    text-transform: uppercase;
    color: var(--muted);
    margin-top: 6px;
  }

  .matchup-display {
    width: 100%;
    max-width: 500px;
    margin-top: 24px;
  }

  .matchup-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 0.9rem;
    letter-spacing: 0.35em;
    color: var(--muted);
    text-align: center;
    margin-bottom: 10px;
  }

  .matchup-cards {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .matchup-card {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 10px 16px;
    position: relative;
    overflow: hidden;
  }

  .matchup-card.active {
    border-color: var(--green);
    box-shadow: 0 0 20px rgba(0,212,106,0.15);
  }

  .matchup-card.upcoming {
    border-color: #333;
    opacity: 0.6;
  }

  .fighter-name {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.3rem;
    letter-spacing: 0.1em;
  }

  .vs-badge {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 0.9rem;
    color: var(--muted);
    letter-spacing: 0.2em;
    padding: 2px 10px;
    border: 1px solid var(--border);
    border-radius: 2px;
  }

  .space-label {
    font-size: 0.65rem;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: var(--muted);
    position: absolute;
    top: 3px;
    left: 16px;
  }

  .controls {
    display: flex;
    gap: 12px;
    margin-top: 28px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .btn {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.1rem;
    letter-spacing: 0.15em;
    padding: 12px 28px;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.15s;
    text-transform: uppercase;
  }

  .btn-start {
    background: var(--green);
    color: #000;
    min-width: 120px;
  }

  .btn-start:hover { filter: brightness(1.1); transform: translateY(-1px); }

  .btn-stop {
    background: var(--red);
    color: #fff;
  }

  .btn-stop:hover { filter: brightness(1.15); }

  .btn-reset {
    background: transparent;
    color: var(--muted);
    border: 1px solid var(--border);
  }

  .btn-reset:hover { border-color: var(--accent); color: var(--accent); }

  /* ===== SIDEBAR ===== */
  .sidebar {
    background: var(--panel);
    overflow-y: auto;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .sidebar-section {
    border: 1px solid var(--border);
    border-radius: 4px;
    overflow: hidden;
  }

  .sidebar-section-header {
    background: #1c1c1c;
    padding: 10px 14px;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 0.85rem;
    letter-spacing: 0.35em;
    color: var(--accent);
    border-bottom: 1px solid var(--border);
    text-transform: uppercase;
  }

  .sidebar-section-body {
    padding: 14px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .setting-row {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  .setting-label {
    font-size: 0.8rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--muted);
  }

  .setting-controls {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .time-input {
    background: #0d0d0d;
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.3rem;
    letter-spacing: 0.1em;
    text-align: center;
    width: 70px;
    padding: 6px;
    border-radius: 3px;
    -moz-appearance: textfield;
  }

  .time-input::-webkit-outer-spin-button,
  .time-input::-webkit-inner-spin-button { -webkit-appearance: none; }

  .time-input:focus { outline: none; border-color: var(--accent); }

  .time-sep {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.3rem;
    color: var(--muted);
  }

  .color-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  /* Participants */
  .participant-input-row {
    display: flex;
    gap: 8px;
  }

  .text-input {
    flex: 1;
    background: #0d0d0d;
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.95rem;
    padding: 8px 10px;
    border-radius: 3px;
  }

  .text-input:focus { outline: none; border-color: var(--accent); }

  .btn-add {
    background: var(--accent);
    color: #000;
    border: none;
    border-radius: 3px;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1rem;
    letter-spacing: 0.1em;
    padding: 8px 14px;
    cursor: pointer;
  }

  .btn-add:hover { filter: brightness(1.1); }

  .participants-list {
    display: flex;
    flex-direction: column;
    gap: 5px;
    max-height: 180px;
    overflow-y: auto;
  }

  .participant-tag {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #0d0d0d;
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 6px 10px;
    font-size: 0.9rem;
  }

  .participant-num {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 0.75rem;
    color: var(--accent);
    margin-right: 8px;
  }

  .btn-remove {
    background: none;
    border: none;
    color: var(--muted);
    cursor: pointer;
    font-size: 1rem;
    line-height: 1;
    padding: 0 2px;
  }

  .btn-remove:hover { color: var(--red); }

  /* Select / Radio */
  .select-input {
    background: #0d0d0d;
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.95rem;
    padding: 7px 10px;
    border-radius: 3px;
    width: 100%;
  }

  .select-input:focus { outline: none; border-color: var(--accent); }

  /* Schedule preview */
  .schedule-list {
    display: flex;
    flex-direction: column;
    gap: 4px;
    max-height: 200px;
    overflow-y: auto;
  }

  .schedule-round {
    background: #0d0d0d;
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 6px 10px;
    font-size: 0.85rem;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .schedule-round-num {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 0.7rem;
    color: var(--accent);
    letter-spacing: 0.2em;
  }

  .schedule-pair {
    color: var(--text);
    font-size: 0.82rem;
  }

  .schedule-round.current-round {
    border-color: var(--green);
  }

  /* ===== Phase color states ===== */
  body.phase-active .time-digits,
  body.phase-active .phase-label { color: var(--green); }
  body.phase-active .timer-ring .progress { stroke: var(--green); }

  body.phase-rest .time-digits,
  body.phase-rest .phase-label { color: var(--red); }
  body.phase-rest .timer-ring .progress { stroke: var(--red); }

  body.phase-warning .time-digits,
  body.phase-warning .phase-label { color: var(--yellow); }
  body.phase-warning .timer-ring .progress { stroke: var(--yellow); }

  body.phase-idle .time-digits { color: var(--text); }
  body.phase-idle .phase-label { color: var(--muted); }
  body.phase-idle .timer-ring .progress { stroke: var(--muted); }

  .pulse { animation: pulse 1s ease-in-out infinite; }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  /* Responsive */
  @media (max-width: 900px) {
    .app-container {
      grid-template-columns: 1fr;
    }
    .timer-section { border-right: none; border-bottom: 1px solid var(--border); }
    .sidebar { max-height: none; }
  }

  .btn-generate {
    width: 100%;
    background: #1c1c1c;
    border: 1px solid var(--accent);
    color: var(--accent);
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1rem;
    letter-spacing: 0.2em;
    padding: 10px;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .btn-generate:hover { background: var(--accent); color: #000; }

  .info-bar {
    font-size: 0.75rem;
    color: var(--muted);
    text-align: center;
    letter-spacing: 0.1em;
  }

  /* Solo Timer Toggle */
  .solo-toggle {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    cursor: pointer;
    padding: 10px 12px;
    border: 1px solid var(--border);
    border-radius: 4px;
    transition: border-color 0.2s, background 0.2s;
    user-select: none;
  }

  .solo-toggle:hover { border-color: var(--accent); }
  .solo-toggle.active { border-color: var(--accent); background: rgba(200,164,90,0.06); }

  .solo-checkbox {
    width: 18px;
    height: 18px;
    border: 2px solid var(--border);
    border-radius: 3px;
    flex-shrink: 0;
    margin-top: 2px;
    position: relative;
    transition: border-color 0.2s, background 0.2s;
  }

  .solo-toggle.active .solo-checkbox {
    border-color: var(--accent);
    background: var(--accent);
  }

  .solo-toggle.active .solo-checkbox::after {
    content: '‚úì';
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    color: #000;
    font-weight: 700;
    line-height: 1;
  }

  .solo-label {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1rem;
    letter-spacing: 0.2em;
    color: var(--text);
  }

  .solo-sub {
    font-size: 0.72rem;
    color: var(--muted);
    letter-spacing: 0.08em;
    margin-top: 2px;
  }
</style>
</head>
<body class="phase-idle">

<header>
  <h1>ü•ä TRAINING ORGANIZER</h1>
  <p>Training Timer &amp; Partner Rotation Manager</p>
</header>

<div class="app-container">
  <!-- MAIN TIMER -->
  <div class="timer-section">
    <div class="phase-label" id="phaseLabel">READY</div>
    <div class="round-info" id="roundInfo">ROUND 0 / 0</div>

    <div class="timer-ring">
      <svg viewBox="0 0 200 200">
        <circle class="track" cx="100" cy="100" r="88"/>
        <circle class="progress" id="progressCircle" cx="100" cy="100" r="88"
          stroke-dasharray="553" stroke-dashoffset="0"/>
      </svg>
      <div class="timer-display">
        <div class="time-digits" id="timeDigits">0:00</div>
        <div class="phase-sub" id="phaseSub">‚Äî SET UP & START ‚Äî</div>
      </div>
    </div>

    <div class="matchup-display" id="matchupDisplay" style="display:none">
      <div class="matchup-title" id="matchupTitle">CURRENT MATCHUPS</div>
      <div class="matchup-cards" id="matchupCards"></div>
    </div>

    <div class="controls">
      <button class="btn btn-start" id="btnStart" onclick="startTimer()">START</button>
      <button class="btn btn-stop" id="btnStop" onclick="stopTimer()" style="display:none">PAUSE</button>
      <button class="btn btn-reset" onclick="resetTimer()">RESET</button>
    </div>

    <div class="info-bar" id="infoBar" style="margin-top:12px"></div>
  </div>

  <!-- SIDEBAR -->
  <div class="sidebar">

    <!-- TIMER SETTINGS -->
    <div class="sidebar-section">
      <div class="sidebar-section-header">‚è± Timer Settings</div>
      <div class="sidebar-section-body">
        <div class="setting-row">
          <div class="setting-label"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:var(--green);margin-right:6px;vertical-align:middle"></span>Round Duration</div>
          <div class="setting-controls">
            <input type="number" class="time-input" id="roundMin" value="2" min="0" max="59" title="Minutes" oninput="updateRotationHint();updateSoloHint()">
            <span class="time-sep">:</span>
            <input type="number" class="time-input" id="roundSec" value="0" min="0" max="59" title="Seconds" oninput="updateRotationHint();updateSoloHint()">
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:var(--red);margin-right:6px;vertical-align:middle"></span>Rest Duration</div>
          <div class="setting-controls">
            <input type="number" class="time-input" id="restMin" value="1" min="0" max="59" oninput="updateRotationHint();updateSoloHint()">
            <span class="time-sep">:</span>
            <input type="number" class="time-input" id="restSec" value="0" min="0" max="59" oninput="updateRotationHint();updateSoloHint()">
          </div>
        </div>
        <div class="setting-row">
          <div class="setting-label"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:var(--yellow);margin-right:6px;vertical-align:middle"></span>Warning Before End</div>
          <div class="setting-controls">
            <input type="number" class="time-input" id="warnSec" value="30" min="0" max="59" style="width:70px">
            <span style="font-size:0.8rem;color:var(--muted);letter-spacing:0.15em">SECONDS</span>
          </div>
        </div>
      </div>
    </div>

    <!-- PARTICIPANTS -->
    <div class="sidebar-section">
      <div class="sidebar-section-header">ü•ä Participants</div>
      <div class="sidebar-section-body">
        <div class="participant-input-row">
          <input type="text" class="text-input" id="participantInput" placeholder="Player name..." maxlength="24"
            onkeydown="if(event.key==='Enter') addParticipant()">
          <button class="btn-add" onclick="addParticipant()">ADD</button>
        </div>
        <div class="participants-list" id="participantsList"></div>
      </div>
    </div>

    <!-- MATCHUP OPTIONS -->
    <div class="sidebar-section">
      <div class="sidebar-section-header">‚öô Matchup Options</div>
      <div class="sidebar-section-body">
        <div class="setting-row">
          <div class="setting-label">Training Pitches (SPACES FOR PAIRS)</div>
          <input type="number" class="time-input" id="numSpaces" value="1" min="1" max="10" style="width:70px" oninput="updateRotationHint()">
        </div>
        <div class="setting-row">
          <div class="setting-label">Schedule Type</div>
          <select class="select-input" id="scheduleType">
            <option value="roundrobin">Round Robin</option>
            <option value="nobacktoback">Minimize Back-to-Back</option>
          </select>
        </div>
        <div class="setting-row">
          <div class="setting-label">Number of Rotations
            <span style="color:var(--muted);font-size:0.68rem;letter-spacing:0.1em"> (everyone works with each other once)</span>
          </div>
          <div class="setting-controls">
            <input type="number" class="time-input" id="numRotations" value="1" min="1" max="20" style="width:70px" oninput="updateRotationHint()">
            <span style="font-size:0.78rem;color:var(--muted);letter-spacing:0.1em" id="rotationHint"></span>
          </div>
        </div>
        <label class="solo-toggle" onclick="toggleSoloMode()">
          <div class="solo-checkbox" id="soloCheckbox"></div>
          <div>
            <div class="solo-label">SOLO ROUND TIMER</div>
            <div class="solo-sub">Ignore Matchups</div>
          </div>
        </label>
        <div id="matchupFields">
          <button class="btn-generate" onclick="generateSchedule()">GENERATE SCHEDULE</button>
        </div>
        <div id="soloStartWrap" style="display:none">
          <div class="setting-row">
            <div class="setting-label">Number of Rounds</div>
            <div class="setting-controls">
              <input type="number" class="time-input" id="soloRounds" value="5" min="1" max="99" style="width:70px" oninput="updateSoloHint()">
              <span style="font-size:0.78rem;color:var(--muted);letter-spacing:0.1em" id="soloHint"></span>
            </div>
          </div>
          <button class="btn-generate" onclick="startSoloTimer()">START SOLO TIMER</button>
        </div>
      </div>
    </div>

    <!-- SCHEDULE PREVIEW -->
    <div class="sidebar-section" id="scheduleSection" style="display:none">
      <div class="sidebar-section-header">üìã Round Schedule</div>
      <div class="sidebar-section-body">
        <div class="schedule-list" id="scheduleList"></div>
        <div class="info-bar" id="scheduleInfo"></div>
      </div>
    </div>

  </div>
</div>

<script>
// ===== AUDIO ENGINE =====
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;

function getAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
  return audioCtx;
}

function playBell(times = 1, interval = 600) {
  const ctx = getAudio();
  for (let i = 0; i < times; i++) {
    setTimeout(() => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      const osc2 = ctx.createOscillator();
      const gain2 = ctx.createGain();

      osc.connect(gain); gain.connect(ctx.destination);
      osc2.connect(gain2); gain2.connect(ctx.destination);

      osc.type = 'sine'; osc.frequency.setValueAtTime(880, ctx.currentTime);
      osc2.type = 'sine'; osc2.frequency.setValueAtTime(1100, ctx.currentTime);

      gain.gain.setValueAtTime(0.6, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.8);
      gain2.gain.setValueAtTime(0.3, ctx.currentTime);
      gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.2);

      osc.start(); osc.stop(ctx.currentTime + 1.8);
      osc2.start(); osc2.stop(ctx.currentTime + 1.2);
    }, i * interval);
  }
}

function playWarningBeep() {
  const ctx = getAudio();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type = 'square'; osc.frequency.value = 660;
  gain.gain.setValueAtTime(0.2, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  osc.start(); osc.stop(ctx.currentTime + 0.15);
}

// ===== STATE =====
let participants = [];
let schedule = []; // Array of rounds, each round = array of pairs [{a,b,space}]
let currentRound = 0;
let currentPhase = 'idle'; // idle | active | warning | rest
let timeRemaining = 0;
let totalPhaseTime = 0;
let timerInterval = null;
let running = false;
let warningFired = false;

// ===== PARTICIPANTS =====
function addParticipant() {
  const inp = document.getElementById('participantInput');
  const name = inp.value.trim();
  if (!name) return;
  if (participants.includes(name)) { inp.value = ''; return; }
  participants.push(name);
  inp.value = '';
  renderParticipants();
}

function removeParticipant(i) {
  participants.splice(i, 1);
  renderParticipants();
}

function renderParticipants() {
  const list = document.getElementById('participantsList');
  list.innerHTML = participants.map((p,i) => `
    <div class="participant-tag">
      <span><span class="participant-num">${i+1}.</span>${p}</span>
      <button class="btn-remove" onclick="removeParticipant(${i})">‚úï</button>
    </div>
  `).join('');
  updateRotationHint();
}

// ===== SCHEDULE GENERATION =====
function updateRotationHint() {
  const n = participants.length;
  const spaces = parseInt(document.getElementById('numSpaces').value) || 1;
  const rotations = parseInt(document.getElementById('numRotations').value) || 1;
  const hint = document.getElementById('rotationHint');
  if (n < 2) { hint.textContent = ''; return; }

  // Estimate rounds per rotation
  const totalPairs = (n * (n - 1)) / 2;
  const roundsPerRotation = Math.ceil(totalPairs / spaces);
  const totalRounds = roundsPerRotation * rotations;

  const roundMin = (parseInt(document.getElementById('roundMin').value)||0) * 60
                 + (parseInt(document.getElementById('roundSec').value)||0);
  const restMin  = (parseInt(document.getElementById('restMin').value)||0) * 60
                 + (parseInt(document.getElementById('restSec').value)||0);
  const totalSec = totalRounds * roundMin + Math.max(0, totalRounds - 1) * restMin;
  const totalMin = Math.round(totalSec / 60);

  hint.textContent = `‚âà ${totalRounds} rounds ¬∑ ${totalMin} min`;
}

function generateSchedule() {
  const n = participants.length;
  const spaces = parseInt(document.getElementById('numSpaces').value) || 1;
  const type = document.getElementById('scheduleType').value;
  const rotations = Math.max(1, parseInt(document.getElementById('numRotations').value) || 1);

  if (n < 2) {
    alert('Add at least 2 participants.');
    return;
  }

  let pairs = [];
  // All unique pairs
  for (let i = 0; i < n; i++)
    for (let j = i+1; j < n; j++)
      pairs.push([i, j]);

  let baseRounds = [];

  if (type === 'roundrobin') {
    baseRounds = buildRoundRobin(participants.map((_,i) => i), spaces);
  } else {
    baseRounds = buildNoBackToBack(pairs, n, spaces);
  }

  // Repeat for the requested number of rotations
  let rounds = [];
  for (let r = 0; r < rotations; r++) {
    rounds = rounds.concat(baseRounds);
  }

  // Convert index pairs to name pairs
  schedule = rounds.map(round =>
    round.map((pair, si) => ({
      a: participants[pair[0]],
      b: participants[pair[1]],
      space: si + 1
    }))
  );

  renderSchedulePreview();
  resetTimer();
  document.getElementById('scheduleSection').style.display = '';
  updateRotationHint();
}

// Round robin: one fighter stays in until they've sparred everyone, then rotate
// Uses a classic round-robin tournament scheduling algorithm
function buildRoundRobin(fighters, spaces) {
  const n = fighters.length;
  const list = [...fighters];
  if (n % 2 !== 0) list.push(-1); // bye
  const total = list.length;
  const rounds = [];

  for (let r = 0; r < total - 1; r++) {
    const pairs = [];
    for (let i = 0; i < total / 2; i++) {
      const a = list[i], b = list[total - 1 - i];
      if (a !== -1 && b !== -1) pairs.push([a, b]);
    }
    // chunk by spaces
    for (let i = 0; i < pairs.length; i += spaces) {
      rounds.push(pairs.slice(i, i + spaces));
    }
    // rotate: keep first fixed, rotate rest
    list.splice(1, 0, list.pop());
  }
  return rounds;
}

// Minimize back-to-back: greedy approach, prefer pairs where neither fighter just sparred
function buildNoBackToBack(allPairs, n, spaces) {
  let remaining = [...allPairs];
  const rounds = [];
  const lastSparred = new Array(n).fill(-1); // last round index each person sparred

  let r = 0;
  while (remaining.length > 0) {
    const used = new Set();
    const round = [];

    // Score pairs: prefer those where both fighters haven't sparred last round
    const scored = remaining.map(p => {
      const gap = Math.min(r - lastSparred[p[0]], r - lastSparred[p[1]]);
      return { p, score: gap };
    }).sort((a, b) => b.score - a.score);

    for (const { p } of scored) {
      if (round.length >= spaces) break;
      if (!used.has(p[0]) && !used.has(p[1])) {
        round.push(p);
        used.add(p[0]);
        used.add(p[1]);
      }
    }

    if (round.length === 0) {
      // fallback: take first available pair
      const fallback = remaining[0];
      round.push(fallback);
    }

    for (const p of round) {
      lastSparred[p[0]] = r;
      lastSparred[p[1]] = r;
      const idx = remaining.findIndex(x => x[0] === p[0] && x[1] === p[1]);
      remaining.splice(idx, 1);
    }

    rounds.push(round);
    r++;
  }
  return rounds;
}

function renderSchedulePreview() {
  const list = document.getElementById('scheduleList');
  const info = document.getElementById('scheduleInfo');
  list.innerHTML = schedule.map((round, i) => `
    <div class="schedule-round ${i === currentRound ? 'current-round' : ''}" id="scheduleRound${i}">
      <div class="schedule-round-num">ROUND ${i + 1}</div>
      ${round.map(m => `<div class="schedule-pair">
        ${schedule[0].length > 1 ? `[Space ${m.space}] ` : ''}${m.a} vs ${m.b}
      </div>`).join('')}
    </div>
  `).join('');
  info.textContent = `${schedule.length} rounds total`;
}

// ===== SOLO MODE =====
let soloMode = false;
let soloTotalRounds = 5;

function toggleSoloMode() {
  soloMode = !soloMode;
  const toggle = document.querySelector('.solo-toggle');
  const matchupFields = document.getElementById('matchupFields');
  const soloStartWrap = document.getElementById('soloStartWrap');
  const scheduleSection = document.getElementById('scheduleSection');

  toggle.classList.toggle('active', soloMode);
  matchupFields.style.display = soloMode ? 'none' : '';
  soloStartWrap.style.display = soloMode ? '' : 'none';

  // Hide schedule section and matchup display when switching modes
  if (soloMode) {
    scheduleSection.style.display = 'none';
    document.getElementById('matchupDisplay').style.display = 'none';
    resetTimer();
  }
  updateSoloHint();
}

function updateSoloHint() {
  const hint = document.getElementById('soloHint');
  if (!hint) return;
  const rounds = parseInt(document.getElementById('soloRounds').value) || 1;
  const roundSec = (parseInt(document.getElementById('roundMin').value)||0)*60 + (parseInt(document.getElementById('roundSec').value)||0);
  const restSec  = (parseInt(document.getElementById('restMin').value)||0)*60  + (parseInt(document.getElementById('restSec').value)||0);
  const totalSec = rounds * roundSec + Math.max(0, rounds - 1) * restSec;
  const totalMin = Math.round(totalSec / 60);
  hint.textContent = `‚âà ${totalMin} min`;
}

function startSoloTimer() {
  soloTotalRounds = Math.max(1, parseInt(document.getElementById('soloRounds').value) || 1);
  // Build a dummy schedule of empty rounds
  schedule = Array.from({ length: soloTotalRounds }, () => []);
  resetTimer();
  // hide schedule section (no matchups)
  document.getElementById('scheduleSection').style.display = 'none';
  document.getElementById('matchupDisplay').style.display = 'none';
  // kick off
  getAudio();
  beginRound();
  document.getElementById('btnStart').style.display = 'none';
  document.getElementById('btnStop').style.display = '';
}


function getRoundDuration() {
  return (parseInt(document.getElementById('roundMin').value)||0) * 60
       + (parseInt(document.getElementById('roundSec').value)||0);
}
function getRestDuration() {
  return (parseInt(document.getElementById('restMin').value)||0) * 60
       + (parseInt(document.getElementById('restSec').value)||0);
}
function getWarnSec() {
  return parseInt(document.getElementById('warnSec').value) || 0;
}

function startTimer() {
  if (soloMode) {
    startSoloTimer();
    return;
  }
  if (schedule.length === 0) {
    alert('Please generate a schedule first.');
    return;
  }
  getAudio(); // unlock
  if (running) return;

  if (currentPhase === 'idle') {
    // Start first round
    beginRound();
  } else {
    // Resume
    running = true;
    timerInterval = setInterval(tick, 1000);
  }

  document.getElementById('btnStart').style.display = 'none';
  document.getElementById('btnStop').style.display = '';
}

function stopTimer() {
  running = false;
  clearInterval(timerInterval);
  document.getElementById('btnStart').style.display = '';
  document.getElementById('btnStop').style.display = 'none';
}

function resetTimer() {
  stopTimer();
  currentRound = 0;
  currentPhase = 'idle';
  timeRemaining = 0;
  warningFired = false;
  setPhaseClass('idle');
  updateDisplay(0, 0, 'READY', '‚Äî SET UP & START ‚Äî');
  document.getElementById('roundInfo').textContent = `ROUND 0 / ${schedule.length}`;
  document.getElementById('matchupDisplay').style.display = 'none';
  document.getElementById('infoBar').textContent = '';
  if (!soloMode && schedule.length > 0) renderSchedulePreview();
}

function beginRound() {
  if (currentRound >= schedule.length) {
    endSession();
    return;
  }
  currentPhase = 'active';
  timeRemaining = getRoundDuration();
  totalPhaseTime = timeRemaining;
  warningFired = false;

  playBell(1);
  setPhaseClass('active');
  updateRoundInfo();
  if (!soloMode) showMatchups('current');
  running = true;
  timerInterval = setInterval(tick, 1000);
}

function beginRest() {
  currentPhase = 'rest';
  timeRemaining = getRestDuration();
  totalPhaseTime = timeRemaining;
  warningFired = false;

  playBell(2);
  setPhaseClass('rest');
  if (!soloMode) showMatchups('upcoming');

  if (timeRemaining <= 0) {
    currentRound++;
    beginRound();
    return;
  }
  running = true;
  timerInterval = setInterval(tick, 1000);
}

function tick() {
  if (!running) return;
  timeRemaining--;

  const warn = getWarnSec();
  const phaseIsActive = currentPhase === 'active' || currentPhase === 'warning';

  if (phaseIsActive && !warningFired && warn > 0 && timeRemaining <= warn) {
    warningFired = true;
    currentPhase = 'warning';
    setPhaseClass('warning');
    playWarningBeep();
  }

  updateTimerRing();
  updateDigits();

  if (timeRemaining <= 0) {
    clearInterval(timerInterval);
    running = false;
    if (currentPhase === 'active' || currentPhase === 'warning') {
      beginRest();
    } else if (currentPhase === 'rest') {
      currentRound++;
      beginRound();
    }
  }
}

function endSession() {
  currentPhase = 'idle';
  setPhaseClass('idle');
  playBell(3, 400);
  updateDisplay(0, 0, 'COMPLETE', '‚Äî SESSION FINISHED ‚Äî');
  document.getElementById('roundInfo').textContent = `ALL ${schedule.length} ROUNDS DONE`;
  document.getElementById('btnStart').style.display = '';
  document.getElementById('btnStop').style.display = 'none';
  running = false;
}

function updateRoundInfo() {
  document.getElementById('roundInfo').textContent = `ROUND ${currentRound + 1} / ${schedule.length}`;
}

function updateDigits() {
  const m = Math.floor(timeRemaining / 60);
  const s = timeRemaining % 60;
  document.getElementById('timeDigits').textContent = `${m}:${s.toString().padStart(2,'0')}`;
  updateTimerRing();
}

function updateDisplay(remaining, total, label, sub) {
  const m = Math.floor(remaining / 60);
  const s = remaining % 60;
  document.getElementById('timeDigits').textContent = `${m}:${s.toString().padStart(2,'0')}`;
  document.getElementById('phaseLabel').textContent = label;
  document.getElementById('phaseSub').textContent = sub;
  updateTimerRingRaw(remaining, total);
}

const CIRC = 2 * Math.PI * 88; // 553
function updateTimerRing() {
  const pct = totalPhaseTime > 0 ? timeRemaining / totalPhaseTime : 0;
  document.getElementById('progressCircle').style.strokeDashoffset = CIRC * (1 - pct);
  document.getElementById('phaseLabel').textContent = currentPhase === 'active' ? 'ROUND' : currentPhase === 'warning' ? 'WARNING' : currentPhase === 'rest' ? 'REST' : 'READY';
  document.getElementById('phaseSub').textContent = (currentPhase === 'rest' && !soloMode) ? '‚Äî NEXT MATCHUPS BELOW ‚Äî' : '';
}

function updateTimerRingRaw(remaining, total) {
  const pct = total > 0 ? remaining / total : 1;
  document.getElementById('progressCircle').style.strokeDashoffset = CIRC * (1 - pct);
}

function setPhaseClass(phase) {
  document.body.className = `phase-${phase}`;
}

// ===== MATCHUP DISPLAY =====
function showMatchups(mode) {
  const display = document.getElementById('matchupDisplay');
  const cards = document.getElementById('matchupCards');
  const title = document.getElementById('matchupTitle');

  if (mode === 'current' && currentRound < schedule.length) {
    title.textContent = 'CURRENT MATCHUPS';
    cards.innerHTML = schedule[currentRound].map(m => `
      <div class="matchup-card active">
        ${schedule[currentRound].length > 1 ? `<span class="space-label">SPACE ${m.space}</span>` : ''}
        <span class="fighter-name">${m.a}</span>
        <span class="vs-badge">VS</span>
        <span class="fighter-name">${m.b}</span>
      </div>
    `).join('');
    display.style.display = '';
    // Highlight schedule
    renderSchedulePreview();
  } else if (mode === 'upcoming') {
    const next = currentRound + 1;
    if (next < schedule.length) {
      title.textContent = 'UP NEXT ‚Äî ROUND ' + (next + 1);
      cards.innerHTML = schedule[next].map(m => `
        <div class="matchup-card upcoming">
          ${schedule[next].length > 1 ? `<span class="space-label">SPACE ${m.space}</span>` : ''}
          <span class="fighter-name">${m.a}</span>
          <span class="vs-badge">VS</span>
          <span class="fighter-name">${m.b}</span>
        </div>
      `).join('');
      display.style.display = '';
    } else {
      title.textContent = 'NEXT ‚Äî FINAL ROUND COMPLETE';
      cards.innerHTML = `<div class="matchup-card" style="justify-content:center;color:var(--accent);font-family:'Bebas Neue',sans-serif;letter-spacing:0.2em">SESSION ENDS AFTER THIS REST</div>`;
      display.style.display = '';
    }
  }
}

// init ring
document.getElementById('progressCircle').style.strokeDasharray = CIRC;
document.getElementById('progressCircle').style.strokeDashoffset = 0;
document.getElementById('progressCircle').style.stroke = 'var(--muted)';
</script>
</body>
</html>
